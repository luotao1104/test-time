# AI Coding Rules  
适用于 Cursor / Claude / Codeium 等所有 AI 工具。

本文件定义 AI 在修改代码前后必须遵守的行为规范。  
任何 AI 开发助手在本仓库中工作时，都应视本文件为“行为准则”。

---

## 0. 核心理念与原则

**核心理念**
> **简洁至上**：恪守KISS（Keep It Simple, Stupid）原则，崇尚简洁与可维护性，避免过度工程化与不必要的防御性设计。
> **深度分析**：立足于第一性原理（First Principles Thinking）剖析问题，并善用工具以提升效率。
> **事实为本**：以事实为最高准则。若有任何谬误，恳请坦率斧正，助我精进。

**开发工作流**
> **渐进式开发**：通过多轮对话迭代，明确并实现需求。在着手任何设计或编码工作前，必须完成前期调研并厘清所有疑点。
> **结构化流程**：严格遵循“构思方案 → 提请审核 → 分解为具体任务”的作业顺序。

**输出规范**
> **语言要求**：所有回复、思考过程及任务清单，均须使用中文。
> **固定指令**：`Implementation Plan, Task List and Thought in Chinese`

---

## 1. 必读文档

在进行任何非琐碎（非机械重复）操作前，AI 必须：

1. 读取：
   - `.aodw/aodw-constitution.md`
   - `.aodw/ai-overview.md`
   - `.aodw/ai-coding-rules.md`（本文件）
   - `.aodw/ai-knowledge-rules.md`
2. 读取当前 RT 目录（如存在）：
   - `RT/RT-XXX/**`
3. 读取相关模块 README：
   - 根据代码路径与 `ai-overview.md` 中的映射，查找对应的模块文档。

如上信息缺失，AI 应主动提示用户并建议创建或补全。

---

## 2. 基本原则

1. **以终为始**  
   - 先明确目标与期望行为，再考虑具体改动。
2. **最小必要修改**  
   - 优先选择最小、可验证、可回滚的改动；
   - 避免大面积“顺手重构”。
3. **不破坏 Invariants**  
   - 在修改前查阅 `invariants.md`、`ai-overview.md` 中的不变条件；
   - 如确需修改，必须走 Spec-Full 流程并更新相关文档。
4. **文档先行，代码随后**  
   - 重要变更应在 spec / plan / impact / invariants 中有记录。

---

## 3. 影响分析（Impact Analysis）

在提出任何解决方案之前，AI 必须生成一份影响分析，并写入当前 RT 的 `impact.md`（或更新之）。

建议结构：

```markdown
## 影响分析 (Impact Analysis)

### 1. 问题触发点
- 入口（界面 / 接口 / 调度任务）：
- 简要复现路径：

### 2. 直接相关模块
- 控制器 / 路由：
- Service：
- Repository / DAO：
- UI 组件：

### 3. 间接影响
- 依赖的共享组件：
- 事件 / 消息链：
- 可能受影响的上下游：

### 4. 风险点
- 潜在数据损坏风险：
- 潜在安全风险：
- 潜在性能风险：
```

---

## 4. 不可破坏原则（Invariants）

在动任何代码前，AI 必须：

1. 打开并检查：
   - `RT/RT-XXX/invariants.md`（如果存在）
   - `.aodw/ai-overview.md` 中的系统级 Invariants
2. 在 `invariants.md` 中列出本次改动必须保持的条件，例如：

```markdown
## 不可破坏行为 (Invariants)

- 保持 /api/v1/orders/{id} 的响应结构不变；
- 保证已存在的订单查询过滤逻辑不受影响；
- 保持用户权限检查机制不被绕过。
```

如发现当前行为已违反 invariants，应先修正文档或代码使其一致，再进行进一步改动。

---

## 5. 方案设计（Solution Design）

AI 提出变更方案时，应：

1. 至少给出 2–3 个不同方案（包括“维持现状但在文档中记录”的选项，如适用）；
2. 对每个方案简要说明：
   - 修改位置；
   - 优点；
   - 缺点；
   - 对风险点的影响；
3. 提供一个 **推荐方案**，并说明推荐理由；
4. 允许用户选择“推荐方案”或指定其他选项。

在 Spec-Full 流程中，方案设计应记录在 `plan.md`；  
在 Spec-Lite 流程中，记录在 `plan-lite.md`。

---

## 6. 修改策略（Safe Modification Strategy）

在修改代码时，AI 应遵守：

1. **局部化修改**  
   - 除非走 Spec-Full 且有充分设计，不进行大范围重构；
   - 尽量只修改与本 RT 相关的模块 / 文件。
2. **分步提交**  
   - 逻辑修改与格式化 / 重排分开提交；
   - 如一次 RT 需要多阶段修改，可分多次提交。
3. **保持兼容**  
   - 在不破坏 Invariants 的前提下，避免改变对外可见行为；
   - 如需要引入 breaking change，必须通过 Spec-Full 并在 `changelog.md` 中记录清晰。

---

## 7. 测试策略（Testing Strategy）

在任何非琐碎修改之后，AI 必须：

1. 在 `RT/RT-XXX/tests.md` 中补充或更新测试点，内容包括：
   - 需要新增的单元测试；
   - 需要回归的集成 / API 测试；
   - 特别需要关注的边界条件；
2. 如项目存在自动化测试框架：
   - 建议具体的测试文件与用例位置；
   - 如可能，直接生成或修改测试代码。

示例条目：

```markdown
- [ ] 为 OrderService.addItem 添加当库存不足时的异常分支测试（tests/orders/order_service.test.ts）
- [ ] 回归测试：用户从“我的订单”页面进入订单详情时的数据加载与权限检查
```

---

## 8. Git Discipline（完成与合并规则）

在完成当前 RT 的实现前，AI 应提示用户执行或确认以下步骤（部分可以自动化脚本完成）：

1. 确认当前在正确的 feature 分支：
   - `feature/RT-XXX-short-name`
2. 确认无未跟踪或未提交但应提交的文件；
3. 确认关键测试已通过（至少本 RT 相关部分）；
4. 合并流程（示例）：
   - 切换到开发主分支（如 `develop` / `mac-version`）；
   - 拉取最新代码；
   - 合并 feature 分支（使用 no-ff 等策略视团队约定而定）；
   - 推送到远程；
5. 打标签：
   - 例如 `done-RT-XXX`；
6. 删除本地 feature 分支；
7. 在 RT 元数据中将状态更新为 `done`，并写入 `changelog.md`。

具体命令可在团队内部脚本中固化，AI 只需遵循流程并提醒用户使用正确脚本。

---

## 9. 用户交互规范

AI 在整个过程中应：

- 始终以选项 + 推荐的形式与用户互动；
- 对关键问题提供简短、明确的推荐理由；
- 在不确定时主动说明不确定性，并请求用户判断；
- 尽量避免把实现细节问题抛给用户决定（除非涉及业务规则）。

用户可以随时要求 AI：

- 展示当前 RT 的 spec / plan / impact / invariants / tests / changelog；
- 解释某项修改或设计决策的原因；
- 回顾本 RT 的整体变更历史。

---

## 10. 任务追踪规范 (Task Tracking)

> **规则**：在执行任何复杂任务（预计 Tool Calls > 3）时，AI 必须维护一个用户可见的 `task.md` Artifact。

- **位置**：当前上下文的 Artifact 区域。
- **更新频率**：每完成一个关键步骤（Sub-task）更新一次。
- **内容**：
  - `[x]` 已完成步骤
  - `[/]` 进行中步骤（高亮）
  - `[ ]` 待执行步骤

**目的**：确保用户能像看进度条一样实时感知 AI 的执行进度，消除“黑盒”焦虑。
